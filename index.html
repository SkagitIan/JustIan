<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Flux Image Generator</title>
  <style>
    :root {
      color-scheme: dark;
      --bg-gradient: linear-gradient(135deg, #0f172a, #1e293b 40%, #0ea5e9);
      --card-bg: rgba(15, 23, 42, 0.75);
      --card-border: rgba(148, 163, 184, 0.2);
      --accent: #38bdf8;
      --accent-strong: #0ea5e9;
      --text: #e2e8f0;
      --muted: #94a3b8;
      --shadow: 0 20px 45px rgba(15, 23, 42, 0.4);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      min-height: 100vh;
      background-image: var(--bg-gradient);
      background-attachment: fixed;
      color: var(--text);
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 2.5rem 1.5rem 1rem;
      text-align: center;
    }

    header h2 {
      margin: 0;
      font-size: clamp(1.8rem, 2.6vw, 2.6rem);
      letter-spacing: 0.08em;
      text-transform: uppercase;
      text-shadow: 0 10px 30px rgba(14, 165, 233, 0.35);
    }

    header p {
      margin: 0.75rem auto 0;
      max-width: 560px;
      color: var(--muted);
      line-height: 1.6;
    }

    main {
      width: min(1100px, 92vw);
      margin: 0 auto 3rem;
      display: grid;
      gap: 1.5rem;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      position: relative;
    }

    .panel {
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 18px;
      padding: 1.75rem;
      backdrop-filter: blur(12px);
      box-shadow: var(--shadow);
      transition: transform 180ms ease, box-shadow 180ms ease;
    }

    .panel:hover {
      transform: translateY(-4px);
      box-shadow: 0 28px 60px rgba(14, 165, 233, 0.18);
    }

    .hidden {
      display: none !important;
    }

    label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 600;
      letter-spacing: 0.03em;
    }

    textarea {
      width: 100%;
      min-height: 150px;
      padding: 1rem;
      border-radius: 14px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      background: rgba(15, 23, 42, 0.35);
      color: inherit;
      font-size: 1rem;
      line-height: 1.5;
      resize: vertical;
      box-shadow: inset 0 0 0 1px rgba(14, 165, 233, 0.08);
    }

    textarea:focus {
      outline: none;
      border-color: rgba(56, 189, 248, 0.6);
      box-shadow: 0 0 0 2px rgba(14, 165, 233, 0.25);
    }

    button {
      padding: 0.75rem 1.4rem;
      border-radius: 12px;
      border: none;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 160ms ease, box-shadow 160ms ease;
      background: linear-gradient(135deg, var(--accent), var(--accent-strong));
      color: #0f172a;
      box-shadow: 0 12px 30px rgba(56, 189, 248, 0.28);
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 16px 35px rgba(56, 189, 248, 0.36);
    }

    button.secondary {
      background: rgba(148, 163, 184, 0.18);
      color: var(--text);
      box-shadow: none;
    }

    button.secondary:hover {
      box-shadow: 0 12px 28px rgba(148, 163, 184, 0.18);
    }

    button:disabled {
      opacity: 0.6;
      cursor: progress;
      box-shadow: none;
      transform: none;
    }

    #prompt-library {
      margin-top: 1rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
    }

    .prompt-pill {
      padding: 0.45rem 0.9rem;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.16);
      color: var(--muted);
      border: 1px solid rgba(148, 163, 184, 0.2);
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
      font-size: 0.9rem;
      font-weight: 500;
      box-shadow: none;
    }

    .prompt-pill:hover {
      background: rgba(56, 189, 248, 0.2);
      color: var(--text);
      transform: translateY(-1px);
    }

    .panel h3 {
      margin-top: 0;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-size: 0.95rem;
      color: var(--muted);
    }

    #status {
      margin-top: 1rem;
      padding: 0.9rem 1.1rem;
      border-radius: 12px;
      background: rgba(14, 165, 233, 0.14);
      color: var(--text);
      border: 1px solid rgba(56, 189, 248, 0.18);
      min-height: 3.1rem;
      display: flex;
      align-items: center;
    }

    #gallery {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 1.2rem;
      margin-top: 1.2rem;
    }

    .image-card {
      position: relative;
      overflow: hidden;
      border-radius: 16px;
      background: rgba(15, 23, 42, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.18);
      box-shadow: inset 0 0 0 1px rgba(14, 165, 233, 0.08),
        0 18px 38px rgba(2, 6, 23, 0.55);
    }

    .image-card img {
      display: block;
      width: 100%;
      height: auto;
    }

    .image-card::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(180deg, transparent, rgba(15, 23, 42, 0.55));
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .image-card:hover::after {
      opacity: 1;
    }

    #preview-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin-top: 1.5rem;
    }

    #login-screen {
      position: fixed;
      inset: 0;
      background: rgba(2, 6, 23, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1.5rem;
      backdrop-filter: blur(6px);
    }

    #login-screen.hidden {
      display: none;
    }

    #login-box {
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 16px;
      padding: 2rem;
      width: 100%;
      max-width: 340px;
      box-shadow: var(--shadow);
      text-align: center;
    }

    #login-box h1 {
      margin-bottom: 0.75rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: var(--accent);
    }

    #login-box input {
      width: 100%;
      padding: 0.75rem 1rem;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.2);
      background: rgba(15, 23, 42, 0.35);
      color: inherit;
      margin-top: 0.75rem;
    }

    #login-error {
      color: #fda4af;
      margin-top: 0.75rem;
      min-height: 1.5rem;
    }

    @media (max-width: 720px) {
      header {
        padding-top: 2rem;
      }

      main {
        grid-template-columns: 1fr;
      }
    }
  </style>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
</head>
<body>
  <div id="login-screen">
    <div id="login-box">
      <h1>Secure Access</h1>
      <form id="login-form">
        <label for="password">Password</label>
        <input id="password" type="password" autocomplete="current-password" />
        <button type="submit">Enter</button>
      </form>
      <div id="login-error"></div>
    </div>
  </div>

  <header>
    <h2>Flux Colossus Image Generator</h2>
    <p>
      Craft striking visuals with a curated prompt library, preview the results, and
      save the keepers straight to Google Drive.
    </p>
  </header>

  <main id="app" class="hidden">
    <section class="panel" id="workflow-panel">
      <h3>Creative Brief</h3>
      <label for="prompt">Tell Flux what to dream</label>
      <textarea id="prompt" placeholder="Describe the scene you want to conjure..."></textarea>
      <div id="prompt-library"></div>
      <button id="generate" type="button">Generate Image</button>
      <div id="status"></div>
    </section>

    <section class="panel hidden" id="preview-panel">
      <h3>Preview</h3>
      <section id="gallery"></section>
      <div id="preview-actions">
        <button id="save-drive" type="button">Save to Google Drive</button>
        <button id="back-dashboard" type="button" class="secondary">Back to Dashboard</button>
      </div>
    </section>
  </main>

  <script type="application/json" id="app-config">
    {
      "replicateToken": "",
      "googleClientId": ""
    }
  </script>
  <script>
    (function () {
      const PASSWORD = "Appertivo2025!";

      function loadConfig() {
        const configNode = document.getElementById("app-config");
        if (!configNode) {
          return {};
        }

        try {
          const parsed = JSON.parse(configNode.textContent || "{}");
          return parsed && typeof parsed === "object" ? parsed : {};
        } catch (error) {
          console.warn("Unable to parse app configuration:", error);
          return {};
        }
      }

      const CONFIG = loadConfig();
      const REPLICATE_TOKEN = CONFIG.replicateToken || "";
      const GOOGLE_CLIENT_ID = CONFIG.googleClientId || "";
      const DRIVE_FOLDER_ID = "";
      const PROMPT_LIBRARY = [
        "Hyper-detailed digital painting of a neon-lit mech warrior emerging from ocean mist, volumetric lighting, cinematic",
        "Macro photograph of bioluminescent mushrooms growing on ancient ruins, surreal glow, shallow depth of field",
        "Architectural concept art of a floating desert oasis city at sunset, soft pastel palette, ultra wide angle"
      ];
      const MODEL_VERSION = "13f8afae9c06740b24e2d22a0fd7b4889c7381f72b49ce9cefc5fff34bdf51e2";

      const loginForm = document.getElementById("login-form");
      const passwordInput = document.getElementById("password");
      const loginError = document.getElementById("login-error");
      const loginScreen = document.getElementById("login-screen");
      const app = document.getElementById("app");
      const promptInput = document.getElementById("prompt");
      const promptLibrary = document.getElementById("prompt-library");
      const generateButton = document.getElementById("generate");
      const statusBox = document.getElementById("status");
      const previewPanel = document.getElementById("preview-panel");
      const gallery = document.getElementById("gallery");
      const saveButton = document.getElementById("save-drive");
      const backButton = document.getElementById("back-dashboard");

      let tokenClient = null;
      let driveAccessToken = null;
      let currentImages = [];

      const savedPrompt = localStorage.getItem("lastPrompt");
      if (savedPrompt) {
        promptInput.value = savedPrompt;
      }

      renderPromptLibrary();
      setStatus("Ready when you are.");

      loginForm.addEventListener("submit", function (event) {
        event.preventDefault();
        if (passwordInput.value === PASSWORD) {
          loginScreen.classList.add("hidden");
          app.classList.remove("hidden");
          loginError.textContent = "";
        } else {
          loginError.textContent = "Incorrect password.";
        }
        passwordInput.value = "";
      });

      promptInput.addEventListener("input", function () {
        localStorage.setItem("lastPrompt", promptInput.value);
      });

      generateButton.addEventListener("click", async function () {
        const prompt = promptInput.value.trim();
        if (!REPLICATE_TOKEN) {
          setStatus("Replicate token is missing. Check your deployment secrets.");
          return;
        }
        if (!prompt) {
          setStatus("Enter a prompt or choose one from the library.");
          return;
        }

        currentImages = [];
        gallery.innerHTML = "";
        previewPanel.classList.add("hidden");
        setStatus("Summoning Flux Colossus...");
        setBusy(generateButton, true);

        try {
          const prediction = await createPrediction(REPLICATE_TOKEN, prompt);
          if (!prediction) {
            setStatus("Unable to start a prediction right now.");
            return;
          }

          const outputUrls = await waitForPrediction(REPLICATE_TOKEN, prediction);
          if (!outputUrls.length) {
            setStatus("No images returned. Try refreshing the prompt.");
            return;
          }

          currentImages = outputUrls;
          showPreview(currentImages);
          setStatus("Preview ready. Save it to Drive or try another idea.");
        } catch (error) {
          console.error(error);
          const message = error instanceof Error ? error.message : String(error);
          setStatus(`Error: ${message}`);
        } finally {
          setBusy(generateButton, false);
        }
      });

      saveButton.addEventListener("click", async function () {
        if (!currentImages.length) {
          setStatus("Generate an image before saving.");
          return;
        }

        setStatus("Preparing Google Drive...");

        try {
          await ensureDriveAccess();
          setStatus("Uploading your artwork to Drive...");
          for (let i = 0; i < currentImages.length; i += 1) {
            await saveToDrive(currentImages[i], i);
          }
          setStatus("Saved! Taking you back to the dashboard.");
          setTimeout(resetPreview, 1200);
        } catch (error) {
          console.error(error);
          setStatus(error.message || "Unable to save to Google Drive right now.");
        }
      });

      backButton.addEventListener("click", function () {
        resetPreview();
        setStatus("Ready for another creation.");
      });

      function renderPromptLibrary() {
        promptLibrary.innerHTML = "";
        PROMPT_LIBRARY.forEach(function (entry) {
          const pill = document.createElement("button");
          pill.type = "button";
          pill.className = "prompt-pill";
          pill.textContent = entry;
          pill.addEventListener("click", function () {
            promptInput.value = entry;
            promptInput.dispatchEvent(new Event("input"));
          });
          promptLibrary.appendChild(pill);
        });
      }

      function showPreview(urls) {
        gallery.innerHTML = "";
        urls.forEach(function (url) {
          const card = document.createElement("div");
          card.className = "image-card";
          const img = document.createElement("img");
          img.src = url;
          img.alt = "Generated artwork";
          card.appendChild(img);
          gallery.appendChild(card);
        });
        previewPanel.classList.remove("hidden");
      }

      function resetPreview() {
        currentImages = [];
        gallery.innerHTML = "";
        previewPanel.classList.add("hidden");
      }

      function setStatus(message) {
        statusBox.textContent = message;
      }

      function setBusy(button, isBusy) {
        button.disabled = isBusy;
        button.textContent = isBusy ? "Generating..." : "Generate Image";
      }

      async function ensureDriveAccess() {
        if (driveAccessToken) {
          return driveAccessToken;
        }

        if (!GOOGLE_CLIENT_ID) {
          throw new Error("Google OAuth client ID is missing. Check your deployment secrets.");
        }

        if (!window.google || !google.accounts || !google.accounts.oauth2) {
          throw new Error("Google auth script is not ready. Please wait a moment.");
        }

        return new Promise(function (resolve, reject) {
          if (!tokenClient) {
            tokenClient = google.accounts.oauth2.initTokenClient({
              client_id: GOOGLE_CLIENT_ID,
              scope: "https://www.googleapis.com/auth/drive.file",
              callback: function (tokenResponse) {
                driveAccessToken = tokenResponse.access_token;
                resolve(driveAccessToken);
              },
              error_callback: function (error) {
                reject(error);
              },
            });
          }

          tokenClient.callback = function (tokenResponse) {
            driveAccessToken = tokenResponse.access_token;
            resolve(driveAccessToken);
          };
          tokenClient.error_callback = function (error) {
            reject(error);
          };

          try {
            tokenClient.requestAccessToken({ prompt: "consent" });
          } catch (error) {
            reject(error);
          }
        });
      }

      async function createPrediction(token, prompt) {
        const response = await fetch("https://api.replicate.com/v1/predictions", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Token ${token}`,
          },
          body: JSON.stringify({
            version: MODEL_VERSION,
            input: { prompt },
          }),
        });

        if (!response.ok) {
          const err = await response.text();
          throw new Error(`Replicate error: ${err}`);
        }
        return response.json();
      }

      async function waitForPrediction(token, prediction) {
        let status = prediction.status;
        let urls = prediction.output || [];

        while (status === "starting" || status === "processing" || status === "queued") {
          await delay(1500);
          const poll = await fetch(`https://api.replicate.com/v1/predictions/${prediction.id}`, {
            headers: { Authorization: `Token ${token}` },
          });
          if (!poll.ok) {
            const err = await poll.text();
            throw new Error(`Polling error: ${err}`);
          }
          const data = await poll.json();
          status = data.status;
          urls = data.output || [];
          setStatus(`Prediction status: ${status}`);
        }

        if (status !== "succeeded") {
          throw new Error(`Prediction finished with status ${status}`);
        }

        return Array.isArray(urls) ? urls : urls ? [urls] : [];
      }

      async function saveToDrive(url, index) {
        if (!driveAccessToken) {
          throw new Error("Drive access token is missing.");
        }

        const response = await fetch(url);
        if (!response.ok) {
          throw new Error("Failed to download image from Replicate");
        }

        const blob = await response.blob();
        const base64Data = await blobToBase64(blob);
        const fileName = `flux_${Date.now()}_${index}.png`;
        const metadata = {
          name: fileName,
          mimeType: blob.type || "image/png",
        };

        if (DRIVE_FOLDER_ID) {
          metadata.parents = [DRIVE_FOLDER_ID];
        }

        const boundary = "boundary" + Math.random().toString(16).slice(2);
        const delimiter = `--${boundary}`;
        const closeDelimiter = `--${boundary}--`;
        const multipartBody = [
          delimiter,
          "Content-Type: application/json; charset=UTF-8",
          "",
          JSON.stringify(metadata),
          delimiter,
          `Content-Type: ${blob.type || "image/png"}`,
          "Content-Transfer-Encoding: base64",
          "",
          base64Data.split(",")[1] || base64Data,
          closeDelimiter,
          "",
        ].join("\r\n");

        const uploadResponse = await fetch("https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart", {
          method: "POST",
          headers: {
            Authorization: `Bearer ${driveAccessToken}`,
            "Content-Type": `multipart/related; boundary=${boundary}`,
          },
          body: multipartBody,
        });

        if (!uploadResponse.ok) {
          const err = await uploadResponse.text();
          throw new Error(`Google Drive upload failed: ${err}`);
        }
      }

      function delay(ms) {
        return new Promise(function (resolve) {
          setTimeout(resolve, ms);
        });
      }

      function blobToBase64(blob) {
        return new Promise(function (resolve, reject) {
          const reader = new FileReader();
          reader.onload = function () {
            resolve(reader.result);
          };
          reader.onerror = function () {
            reject(reader.error);
          };
          reader.readAsDataURL(blob);
        });
      }
    })();
  </script>
</body>
</html>
